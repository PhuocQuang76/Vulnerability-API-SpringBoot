package com.Vulnerability.API.controller;

import com.Vulnerability.API.DTO.SeverityReport;
import com.Vulnerability.API.modal.Vulnerability;
import com.Vulnerability.API.service.VulnerabilityService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.text.DecimalFormat;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

@RestController
public class VulnerabilityController {
    @Autowired
    VulnerabilityService vulnerabilityService;

    @GetMapping("/welcome")
    public String welcome() {
        return "HI AILEEN";
    }

    @PostMapping("/saveVulnerability")
    public Vulnerability saveVulnerability(@RequestBody Vulnerability vulnerability) {
        Vulnerability vulnerabilityData = vulnerabilityService.findById(vulnerability.getId());
        if (vulnerabilityData == null) {
            System.out.println("Save.....");
            return vulnerabilityService.saveVulnerability(vulnerability);
        } else {
            return null;
        }
    }


    @GetMapping("/vulnerability/{id}")
    public ResponseEntity<Vulnerability> getVulnerability(@PathVariable Long id) {
        HttpHeaders httpHeaders = new HttpHeaders();

        Vulnerability vulnerability = vulnerabilityService.findById(id);
        if (vulnerability != null) {
            System.out.println("Vulnerability Found -------.");
            return new ResponseEntity<>(vulnerability, HttpStatus.OK);
        } else {
            System.out.println("Vulnerability Not Found -------");
            return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
        }
    }

    /*

    delete request to delete the vulnerability with the given id and return status code 200.
    Delete means the vulnerability is logically deleted - not completely removed from the database;
    If Vulnerability doent exist in the database it shoud return the status code  404
     */
    @DeleteMapping("/vulnerability/{id}")
    public ResponseEntity<Vulnerability> deleteIfExist(@PathVariable Long id) {
        HttpHeaders httpHeaders = new HttpHeaders();

        Vulnerability vulnerability = vulnerabilityService.findById(id);
        if (vulnerability == null) {
            System.out.println("Vulnerability NOT FOUND -------.");
            return new ResponseEntity<>(null, HttpStatus.NOT_FOUND);
        } else {
            // Perform logical deletion here by updating the 'deleted' flag
            vulnerability.setDeleted(true);
            vulnerabilityService.saveVulnerability(vulnerability); // Save the updated entity

            return new ResponseEntity<>(vulnerability, HttpStatus.OK);
        }
    }


    /*
    api /vulnerability/search/{product}?orderBy={orderBy}
    Return the vulnerabilities filtered by product and sorted by the given column with status code 200
    When the given code order by column doesnt exist, return status code 400
     */
    @GetMapping("/vulnerability/search/{product}")
    public ResponseEntity<?> searchVulnerabilityByProductOrderBy(@PathVariable String product, @RequestParam(required = false) String orderBy) {
        List<Vulnerability> vulnerabilities = vulnerabilityService.findByProduct(product);

        if (orderBy != null) {
            // Check if the orderBy column exists in the Vulnerability entity
            if (!isValidOrderByColumn(orderBy)) {
                return new ResponseEntity<>("Invalid orderBy column", HttpStatus.BAD_REQUEST);
            }


            // Sort the vulnerabilities by the specified column
            vulnerabilities.sort(Comparator.comparing(v -> getOrderByFieldValue(v, orderBy)));
        }
        return new ResponseEntity<>(vulnerabilities, HttpStatus.OK);
    }

    private boolean isValidOrderByColumn (String column){
        // Implement logic to check if the column is a valid field in the Vulnerability entity
        // For example, check if the field exists in the entity class
        return Arrays.asList("id", "title", "score", "severity", "product", "deleted").contains(column);
    }

    private String getOrderByFieldValue(Vulnerability vulnerability, String orderBy) {
        // Implement logic to get the field value based on the orderBy column
        // You can use reflection or switch case to extract the field value from the Vulnerability object
        switch (orderBy) {
            case "id":
                return String.valueOf(vulnerability.getId());
            case "title":
                return vulnerability.getTitle();
            case "score":
                return vulnerability.getScore();
            case "severity":
                return vulnerability.getSeverity();
            case "product":
                return vulnerability.getProduct();
            case "deleted":
                return String.valueOf(vulnerability.isDeleted());
            default:
                return "";
        }
    }


    /*
    GET /vulnerability/report/severityDashboard
    It need to generate a report like the JSON below where it needs to group by the severity level across the whole sataset
    THe result needs to be sorted on severity level of null or empty from the calculation
    Exclude the entried wihch have a severity level of null or empty from the calculation
    [
    {
        "severity":"High",
        "Score":8.9,
        "percent":20.0
    },
    {
        "severity":"Medium",
        "Score":6.9,
        "percent":50.0
    },
    {
        "severity":"Low",
        "Score":3.9,
        "percent":30.0
    }

    ]
     */

    @GetMapping("/vulnerability/report/severityDashboard")
    public List<SeverityReport> generateReport(){
        List<String> severityOrder = List.of("High","Medium","Low");
        List<Vulnerability> vulnerabilities = vulnerabilityService.getAllVulnerability();
        if(vulnerabilities != null){
            List<SeverityReport> reports = calculateVulnerabilityBySeverityOrder(vulnerabilities);
            return sortSeverityReports(reports);

        }else{
            return null;
        }

    }

    private static List<SeverityReport> calculateVulnerabilityBySeverityOrder(List<Vulnerability> vulnerabilities){
        DecimalFormat df = new DecimalFormat("#.##");
        return vulnerabilities.stream()
                .collect(Collectors.groupingBy(Vulnerability::getSeverity,
                        Collectors.collectingAndThen(Collectors.toList(), list -> {
                            double averageScore = list.stream()
                                    .mapToDouble(v -> Double.parseDouble(v.getScore()))
                                    .average()
                                    .orElse(0.0);

                            double totalVulnerabilities = vulnerabilities.size();
                            String percent = df.format((list.size() / totalVulnerabilities) * 100);

                            SeverityReport report = new SeverityReport();
                            report.setServerity(list.get(0).getSeverity());
                            report.setScore(averageScore);
                            report.setPercent(Double.valueOf(percent));

                            return report;
                        }))
                )
                .values()
                .stream()
                .collect(Collectors.toList());

    }

    private static List<SeverityReport> sortSeverityReports(List<SeverityReport> severityReports) {
        List<String> severityOrder = List.of("High", "Medium", "Low");

        return severityReports.stream()
                .filter(report -> report.getServerity() != null && !report.getServerity().isEmpty() && report.getPercent() != 0.0)
                .sorted(Comparator.comparingInt(severityReport ->
                        severityOrder.indexOf(severityReport.getServerity())))
                .collect(Collectors.toList());
    }
}
